import {
  __commonJS
} from "./chunk-HYZYPRER.js";

// node_modules/@upload-io/upload-api-client-upload-js/dist/main.js
var require_main = __commonJS({
  "node_modules/@upload-io/upload-api-client-upload-js/dist/main.js"(exports, module) {
    module.exports = /******/
    function() {
      "use strict";
      var __webpack_modules__ = {
        /***/
        "./src/index.ts": (
          /***/
          function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, {
              "beginMultipartUpload": function() {
                return (
                  /* reexport */
                  beginMultipartUpload
                );
              },
              "completeUploadPart": function() {
                return (
                  /* reexport */
                  completeUploadPart
                );
              },
              "getUploadPart": function() {
                return (
                  /* reexport */
                  getUploadPart
                );
              },
              "request": function() {
                return (
                  /* reexport */
                  request
                );
              }
            });
            ;
            function _await(value, then, direct) {
              if (direct) {
                return then ? then(value) : value;
              }
              if (!value || !value.then) {
                value = Promise.resolve(value);
              }
              return then ? value.then(then) : value;
            }
            function _async(f) {
              return function() {
                for (var args = [], i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                try {
                  return Promise.resolve(f.apply(this, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
            }
            var request = _async(function(config, options) {
              var url = getUrl(config, options);
              return _await(sendRequest(config, options, url), function(response) {
                var responseBody = getResponseBody(response);
                var responseHeader = getResponseHeader(response, options.responseHeader);
                return {
                  url,
                  ok: response.status >= 200 && response.status < 300,
                  status: response.status,
                  statusText: response.statusText,
                  body: responseHeader || responseBody
                };
              });
            });
            var sendRequest = _async(function(config, options, url) {
              var xhr = new XMLHttpRequest();
              xhr.open(options.method, url, true);
              xhr.withCredentials = config.WITH_CREDENTIALS;
              return _await(getHeaders(config, options), function(headers) {
                headers.forEach(function(value, key) {
                  xhr.setRequestHeader(key, value);
                });
                return new Promise(function(resolve2) {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                      resolve2(xhr);
                    }
                  };
                  xhr.send(getRequestBody(options));
                });
              });
            });
            var getHeaders = _async(function(config, options) {
              return _await(resolve(options, config.USERNAME), function(username) {
                return _await(resolve(options, config.PASSWORD), function(password) {
                  return _await(resolve(options, config.HEADERS), function(defaultHeaders) {
                    var headers = new Headers(Object.assign(Object.assign({
                      Accept: contentTypeJson
                    }, defaultHeaders), options.headers));
                    if (isStringWithValue(username) && isStringWithValue(password)) {
                      var credentials = btoa("".concat(username, ":").concat(password));
                      headers.append("Authorization", "Basic ".concat(credentials));
                    }
                    if (options.body) {
                      headers.append(contentType, contentTypeJson);
                    }
                    return headers;
                  });
                });
              });
            });
            var resolve = _async(function(options, resolver) {
              return typeof resolver === "function" ? resolver(options) : resolver;
            });
            var contentType = "Content-Type";
            var contentTypeJson = "application/json";
            function isDefined(value) {
              return value !== void 0 && value !== null;
            }
            function isStringWithValue(value) {
              return typeof value === "string" && value !== "";
            }
            function getQueryString(params) {
              var qs = [];
              Object.keys(params).forEach(function(key) {
                var value = params[key];
                if (isDefined(value)) {
                  if (Array.isArray(value)) {
                    value.forEach(function(value2) {
                      qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(String(value2))));
                    });
                  } else {
                    qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(String(value))));
                  }
                }
              });
              if (qs.length > 0) {
                return "?".concat(qs.join("&"));
              }
              return "";
            }
            function getUrl(config, options) {
              var path = options.path.replace(/[:]/g, "_");
              var url = "".concat(config.BASE).concat(path);
              if (options.query) {
                return "".concat(url).concat(getQueryString(options.query));
              }
              return url;
            }
            function getRequestBody(options) {
              if (options.body) {
                return JSON.stringify(options.body);
              }
              return void 0;
            }
            function getResponseHeader(xhr, responseHeader) {
              if (responseHeader) {
                return xhr.getResponseHeader(responseHeader);
              }
              return null;
            }
            function getResponseBody(xhr) {
              var headerValue = xhr.getResponseHeader(contentType);
              if (headerValue) {
                var isJSON = headerValue.toLowerCase().startsWith(contentTypeJson);
                if (isJSON) {
                  return JSON.parse(xhr.responseText);
                } else {
                  return xhr.responseText;
                }
              }
              return null;
            }
            ;
            function UploadsService_await(value, then, direct) {
              if (direct) {
                return then ? then(value) : value;
              }
              if (!value || !value.then) {
                value = Promise.resolve(value);
              }
              return then ? value.then(then) : value;
            }
            function UploadsService_async(f) {
              return function() {
                for (var args = [], i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                try {
                  return Promise.resolve(f.apply(this, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
            }
            var getUploadPart = UploadsService_async(function(config, accountId, uploadId, uploadPartIndex) {
              return request(config, {
                method: "GET",
                path: "".concat(accounts).concat(accountId).concat(uploads, "/").concat(uploadId).concat(parts).concat(uploadPartIndex)
              });
            });
            var completeUploadPart = UploadsService_async(function(config, accountId, uploadId, uploadPartIndex, requestBody) {
              return request(config, {
                method: "PUT",
                path: "".concat(accounts).concat(accountId).concat(uploads, "/").concat(uploadId).concat(parts).concat(uploadPartIndex),
                body: requestBody
              });
            });
            var beginMultipartUpload = UploadsService_async(function(config, accountId, requestBody) {
              return request(config, {
                method: "POST",
                path: "".concat(accounts).concat(accountId).concat(uploads),
                body: requestBody
              });
            });
            var accounts = "/v2/accounts/";
            var uploads = "/uploads";
            var parts = "/parts/";
            ;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        if (__webpack_module_cache__[moduleId]) {
          return __webpack_module_cache__[moduleId].exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      !function() {
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      }();
      return __webpack_require__("./src/index.ts");
    }();
  }
});

// node_modules/progress-smoother/dist/main.js
var require_main2 = __commonJS({
  "node_modules/progress-smoother/dist/main.js"(exports, module) {
    module.exports = /******/
    function() {
      "use strict";
      var __webpack_modules__ = {
        /***/
        "./src/index.ts": (
          /***/
          function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, {
              "ProgressSmoother": function() {
                return (
                  /* reexport */
                  ProgressSmoother
                );
              }
            });
            ;
            function ProgressSmoother(config) {
              var _a, _b;
              var minFinishDuration = 1e3;
              var maxForecastFactor = 0.33;
              var minSetupTime = (_a = config.minDelayUntilFirstValue) !== null && _a !== void 0 ? _a : 0;
              var minTeardownTime = (_b = config.teardownTime) !== null && _b !== void 0 ? _b : 0;
              var valueIncreaseRatePerSecond = config.valueIncreaseRatePerSecond, averageTimeBetweenValues = config.averageTimeBetweenValues, maxValue = config.maxValue, valueIncreaseDelta = config.valueIncreaseDelta;
              var _lastReading;
              var lastTimeMinus1 = Date.now();
              var lastYieldedValue = 0;
              var movingAverage = 0;
              function returnMonotonic(getValue) {
                var value = getValue();
                if (value > lastYieldedValue) {
                  lastYieldedValue = value;
                }
                return lastYieldedValue;
              }
              function hasFinished(lastReading) {
                return lastReading.value === maxValue;
              }
              function fromLastReading(lastReading, now) {
                if (hasFinished(lastReading)) {
                  var teardownTime = Math.max(minFinishDuration, minTeardownTime);
                  var millisElapsed = now - lastReading.time;
                  var percentageIntoTeardown = millisElapsed / teardownTime;
                  var percentageIntoTeardownCapped = Math.min(1, percentageIntoTeardown);
                  var percentageIntoTeardownEased = easeInQuad(percentageIntoTeardownCapped);
                  var delta = lastReading.value - movingAverage;
                  return movingAverage + delta * percentageIntoTeardownEased;
                }
                return calculateEMA(lastReading.value, now, lastTimeMinus1);
              }
              function forecastInitialValue(now) {
                var maxForecastSize = Math.min(valueIncreaseDelta, maxValue * maxForecastFactor);
                var maxForecastTransferTime = maxForecastSize / valueIncreaseRatePerSecond * 1e3;
                var maxTwiddleTime = minSetupTime + maxForecastTransferTime;
                var millisElapsed = now - lastTimeMinus1;
                var percentageIntoTwiddleTime = millisElapsed / maxTwiddleTime;
                var percentageIntoTwiddleTimeCapped = Math.min(1, percentageIntoTwiddleTime);
                return percentageIntoTwiddleTimeCapped * maxForecastSize;
              }
              function alpha(now, lastTime) {
                var alphaMagicNumber = 3.5;
                return 1 - Math.exp(-(now - lastTime) / (averageTimeBetweenValues * alphaMagicNumber));
              }
              function calculateEMA(value, now, lastTime) {
                var a = alpha(now, lastTime);
                return a * value + (1 - a) * movingAverage;
              }
              function easeInQuad(x) {
                return x * x;
              }
              function setValue(value, nowMaybe) {
                if (_lastReading !== void 0) {
                  if (hasFinished(_lastReading)) {
                    return;
                  }
                  movingAverage = calculateEMA(_lastReading.value, _lastReading.time, lastTimeMinus1);
                  lastTimeMinus1 = _lastReading.time;
                }
                _lastReading = {
                  time: nowMaybe !== null && nowMaybe !== void 0 ? nowMaybe : Date.now(),
                  value: Math.min(value, maxValue)
                };
              }
              function smoothedValue(nowMaybe) {
                return returnMonotonic(function() {
                  var now = nowMaybe !== null && nowMaybe !== void 0 ? nowMaybe : Date.now();
                  if (_lastReading !== void 0) {
                    return fromLastReading(_lastReading, now);
                  }
                  return forecastInitialValue(now);
                });
              }
              function smoothedFactor(nowMaybe) {
                return smoothedValue(nowMaybe) / maxValue;
              }
              return {
                setValue,
                smoothedValue,
                smoothedFactor
              };
            }
            ;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        if (__webpack_module_cache__[moduleId]) {
          return __webpack_module_cache__[moduleId].exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      !function() {
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      }();
      return __webpack_require__("./src/index.ts");
    }();
  }
});

// node_modules/upload-js/dist/main.js
var require_main3 = __commonJS({
  "node_modules/upload-js/dist/main.js"(exports, module) {
    module.exports = /******/
    function() {
      "use strict";
      var __webpack_modules__ = {
        /***/
        "./src/index.ts": (
          /***/
          function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, {
              "Upload": function() {
                return (
                  /* reexport */
                  Upload
                );
              },
              "UploadApiError": function() {
                return (
                  /* reexport */
                  UploadApiError
                );
              }
            });
            ;
            var upload_api_client_upload_js_namespaceObject = require_main();
            ;
            ;
            function _call(body, then, direct) {
              if (direct) {
                return then ? then(body()) : body();
              }
              try {
                var result = Promise.resolve(body());
                return then ? result.then(then) : result;
              } catch (e) {
                return Promise.reject(e);
              }
            }
            function _rethrow(thrown, value) {
              if (thrown)
                throw value;
              return value;
            }
            function _finallyRethrows(body, finalizer) {
              try {
                var result = body();
              } catch (e) {
                return finalizer(true, e);
              }
              if (result && result.then) {
                return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
              }
              return finalizer(false, result);
            }
            function _empty() {
            }
            function _awaitIgnored(value, direct) {
              if (!direct) {
                return value && value.then ? value.then(_empty) : Promise.resolve();
              }
            }
            function _settle(pact, state, value) {
              if (!pact.s) {
                if (value instanceof _Pact) {
                  if (value.s) {
                    if (state & 1) {
                      state = value.s;
                    }
                    value = value.v;
                  } else {
                    value.o = _settle.bind(null, pact, state);
                    return;
                  }
                }
                if (value && value.then) {
                  value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
                  return;
                }
                pact.s = state;
                pact.v = value;
                var observer = pact.o;
                if (observer) {
                  observer(pact);
                }
              }
            }
            var _Pact = function() {
              function _Pact2() {
              }
              _Pact2.prototype.then = function(onFulfilled, onRejected) {
                var result = new _Pact2();
                var state = this.s;
                if (state) {
                  var callback = state & 1 ? onFulfilled : onRejected;
                  if (callback) {
                    try {
                      _settle(result, 1, callback(this.v));
                    } catch (e) {
                      _settle(result, 2, e);
                    }
                    return result;
                  } else {
                    return this;
                  }
                }
                this.o = function(_this) {
                  try {
                    var value = _this.v;
                    if (_this.s & 1) {
                      _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
                    } else if (onRejected) {
                      _settle(result, 1, onRejected(value));
                    } else {
                      _settle(result, 2, value);
                    }
                  } catch (e) {
                    _settle(result, 2, e);
                  }
                };
                return result;
              };
              return _Pact2;
            }();
            function _isSettledPact(thenable) {
              return thenable instanceof _Pact && thenable.s & 1;
            }
            function _for(test, update, body) {
              var stage;
              for (; ; ) {
                var shouldContinue = test();
                if (_isSettledPact(shouldContinue)) {
                  shouldContinue = shouldContinue.v;
                }
                if (!shouldContinue) {
                  return result;
                }
                if (shouldContinue.then) {
                  stage = 0;
                  break;
                }
                var result = body();
                if (result && result.then) {
                  if (_isSettledPact(result)) {
                    result = result.s;
                  } else {
                    stage = 1;
                    break;
                  }
                }
                if (update) {
                  var updateValue = update();
                  if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
                    stage = 2;
                    break;
                  }
                }
              }
              var pact = new _Pact();
              var reject = _settle.bind(null, pact, 2);
              (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
              return pact;
              function _resumeAfterBody(value) {
                result = value;
                do {
                  if (update) {
                    updateValue = update();
                    if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
                      updateValue.then(_resumeAfterUpdate).then(void 0, reject);
                      return;
                    }
                  }
                  shouldContinue = test();
                  if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
                    _settle(pact, 1, result);
                    return;
                  }
                  if (shouldContinue.then) {
                    shouldContinue.then(_resumeAfterTest).then(void 0, reject);
                    return;
                  }
                  result = body();
                  if (_isSettledPact(result)) {
                    result = result.v;
                  }
                } while (!result || !result.then);
                result.then(_resumeAfterBody).then(void 0, reject);
              }
              function _resumeAfterTest(shouldContinue2) {
                if (shouldContinue2) {
                  result = body();
                  if (result && result.then) {
                    result.then(_resumeAfterBody).then(void 0, reject);
                  } else {
                    _resumeAfterBody(result);
                  }
                } else {
                  _settle(pact, 1, result);
                }
              }
              function _resumeAfterUpdate() {
                if (shouldContinue = test()) {
                  if (shouldContinue.then) {
                    shouldContinue.then(_resumeAfterTest).then(void 0, reject);
                  } else {
                    _resumeAfterTest(shouldContinue);
                  }
                } else {
                  _settle(pact, 1, result);
                }
              }
            }
            function _continue(value, then) {
              return value && value.then ? value.then(then) : then(value);
            }
            function _async(f) {
              return function() {
                for (var args = [], i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                try {
                  return Promise.resolve(f.apply(this, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
            }
            function Mutex() {
              var mutex;
              var resolver;
              var safe = function safe2(callback) {
                return _call(acquire, function() {
                  return _finallyRethrows(callback, function(_wasThrown, _result) {
                    release();
                    return _rethrow(_wasThrown, _result);
                  });
                });
              };
              var acquire = _async(function() {
                return _continue(_for(function() {
                  return mutex !== void 0;
                }, void 0, function() {
                  return _awaitIgnored(mutex);
                }), function() {
                  mutex = new Promise(function(resolve) {
                    resolver = resolve;
                  });
                });
              });
              var release = function release2() {
                if (resolver === void 0) {
                  throw new Error("Unable to release mutex: already released.");
                }
                resolver();
                resolver = void 0;
                mutex = void 0;
              };
              return {
                safe
              };
            }
            ;
            var external_progress_smoother_namespaceObject = require_main2();
            ;
            ;
            function _typeof(obj) {
              "@babel/helpers - typeof";
              return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
              } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              }, _typeof(obj);
            }
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              Object.defineProperty(subClass, "prototype", { writable: false });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self, call) {
              if (call && (_typeof(call) === "object" || typeof call === "function")) {
                return call;
              } else if (call !== void 0) {
                throw new TypeError("Derived constructors may only return object or undefined");
              }
              return _assertThisInitialized(self);
            }
            function _assertThisInitialized(self) {
              if (self === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self;
            }
            function _wrapNativeSuper(Class) {
              var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
              _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                if (Class2 === null || !_isNativeFunction(Class2))
                  return Class2;
                if (typeof Class2 !== "function") {
                  throw new TypeError("Super expression must either be null or a function");
                }
                if (typeof _cache !== "undefined") {
                  if (_cache.has(Class2))
                    return _cache.get(Class2);
                  _cache.set(Class2, Wrapper);
                }
                function Wrapper() {
                  return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                }
                Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                return _setPrototypeOf(Wrapper, Class2);
              };
              return _wrapNativeSuper(Class);
            }
            function _construct(Parent, args, Class) {
              if (_isNativeReflectConstruct()) {
                _construct = Reflect.construct;
              } else {
                _construct = function _construct2(Parent2, args2, Class2) {
                  var a = [null];
                  a.push.apply(a, args2);
                  var Constructor = Function.bind.apply(Parent2, a);
                  var instance = new Constructor();
                  if (Class2)
                    _setPrototypeOf(instance, Class2.prototype);
                  return instance;
                };
              }
              return _construct.apply(null, arguments);
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _isNativeFunction(fn) {
              return Function.toString.call(fn).indexOf("[native code]") !== -1;
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            var UploadApiError = function(_Error) {
              _inherits(UploadApiError2, _Error);
              var _super = _createSuper(UploadApiError2);
              function UploadApiError2(response) {
                var _this;
                _classCallCheck(this, UploadApiError2);
                _this = _super.call(this, response.error.message);
                _this.errorCode = response.error.code;
                _this.details = response.error.details;
                return _this;
              }
              return _createClass(UploadApiError2);
            }(_wrapNativeSuper(Error));
            ;
            function Upload_rethrow(thrown, value) {
              if (thrown)
                throw value;
              return value;
            }
            function Upload_finallyRethrows(body, finalizer) {
              try {
                var result = body();
              } catch (e) {
                return finalizer(true, e);
              }
              if (result && result.then) {
                return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
              }
              return finalizer(false, result);
            }
            function _continueIgnored(value) {
              if (value && value.then) {
                return value.then(Upload_empty);
              }
            }
            function _toConsumableArray(arr) {
              return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
            }
            function _nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen);
            }
            function _iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function _arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return _arrayLikeToArray(arr);
            }
            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function Upload_empty() {
            }
            var accountIdLength = 7;
            function Upload_awaitIgnored(value, direct) {
              if (!direct) {
                return value && value.then ? value.then(Upload_empty) : Promise.resolve();
              }
            }
            var specialApiKeyAccountId = "W142hJk";
            function Upload_async(f) {
              return function() {
                for (var args = [], i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                try {
                  return Promise.resolve(f.apply(this, args));
                } catch (e) {
                  return Promise.reject(e);
                }
              };
            }
            var specialApiKeys = ["free", "demo"];
            function _await(value, then, direct) {
              if (direct) {
                return then ? then(value) : value;
              }
              if (!value || !value.then) {
                value = Promise.resolve(value);
              }
              return then ? value.then(then) : value;
            }
            var apiKeyPrefix = "public_";
            function Upload_call(body, then, direct) {
              if (direct) {
                return then ? then(body()) : body();
              }
              try {
                var result = Promise.resolve(body());
                return then ? result.then(then) : result;
              } catch (e) {
                return Promise.reject(e);
              }
            }
            var maxUploadConcurrency = 5;
            function _callIgnored(body, direct) {
              return Upload_call(body, Upload_empty, direct);
            }
            var refreshBeforeExpirySeconds = 20;
            function _catch(body, recover) {
              try {
                var result = body();
              } catch (e) {
                return recover(e);
              }
              if (result && result.then) {
                return result.then(void 0, recover);
              }
              return result;
            }
            var onProgressInterval = 100;
            function _invokeIgnored(body) {
              var result = body();
              if (result && result.then) {
                return result.then(Upload_empty);
              }
            }
            var retryAuthAfterErrorSeconds = 5;
            var minJwtTtlSeconds = 10;
            var accessTokenPathBase = "/api/v1/access_tokens/";
            var logPrefix = "[upload-js] ";
            function Upload(config) {
              var _a, _b, _c, _d, _e, _f, _g, _h, _j;
              var accountId;
              var authMutex = Mutex();
              var apiUrl = (_b = (_a = config.internal) === null || _a === void 0 ? void 0 : _a.apiUrl) !== null && _b !== void 0 ? _b : "https://api.upload.io";
              var cdnUrl = (_d = (_c = config.internal) === null || _c === void 0 ? void 0 : _c.cdnUrl) !== null && _d !== void 0 ? _d : "https://upcdn.io";
              var authenticateWithApiKey = (_f = (_e = config.internal) === null || _e === void 0 ? void 0 : _e.authenticateWithApiKey) !== null && _f !== void 0 ? _f : true;
              var headers = (_g = config.internal) === null || _g === void 0 ? void 0 : _g.headers;
              var debugMode = config.debug === true;
              var lastAuthSession;
              if ((config !== null && config !== void 0 ? config : void 0) === void 0) {
                throw new Error("".concat(logPrefix, "Config parameter required."));
              }
              if (config.debug === true) {
                console.log("".concat(logPrefix, "Initialized with API key '").concat(config.apiKey, "'"));
              }
              if (((_h = config.apiKey) !== null && _h !== void 0 ? _h : void 0) === void 0) {
                throw new Error("".concat(logPrefix, "Please provide an API key via the 'apiKey' config parameter."));
              }
              if (config.apiKey.trim() !== config.apiKey) {
                throw new Error("".concat(logPrefix, "API key needs trimming (whitespace detected)."));
              }
              if (((_j = config.internal) === null || _j === void 0 ? void 0 : _j.authenticateWithApiKey) === false) {
                accountId = config.internal.accountId;
              } else {
                if (specialApiKeys.includes(config.apiKey)) {
                  accountId = specialApiKeyAccountId;
                } else {
                  if (!config.apiKey.startsWith(apiKeyPrefix)) {
                    throw new Error("".concat(logPrefix, 'API key must begin with "').concat(apiKeyPrefix, '".'));
                  }
                  accountId = config.apiKey.substr(apiKeyPrefix.length, accountIdLength);
                  if (accountId.length !== accountIdLength) {
                    throw new Error("".concat(logPrefix, "API key is too short!"));
                  }
                }
              }
              var accessTokenUrl = "".concat(cdnUrl).concat(accessTokenPathBase).concat(accountId);
              var beginAuthSession = Upload_async(function(authUrl, authHeaders) {
                return Upload_awaitIgnored(callAuthMethod(Upload_async(function(x) {
                  return x.beginAuthSession(authUrl, authHeaders);
                }), function() {
                  return Upload_call(endAuthSession, function() {
                    var authSession = {
                      accessToken: void 0,
                      accessTokenRefreshHandle: void 0,
                      isActive: true
                    };
                    lastAuthSession = authSession;
                    return Upload_awaitIgnored(refreshAccessToken(authUrl, authHeaders, authSession));
                  });
                }));
              });
              var endAuthSession = Upload_async(function() {
                return Upload_awaitIgnored(callAuthMethod(Upload_async(function(x) {
                  return x.endAuthSession();
                }), Upload_async(function() {
                  return Upload_awaitIgnored(authMutex.safe(Upload_async(function() {
                    if (lastAuthSession === void 0) {
                      return;
                    }
                    var authSession = lastAuthSession;
                    lastAuthSession = void 0;
                    if (authSession.accessTokenRefreshHandle !== void 0) {
                      clearTimeout(authSession.accessTokenRefreshHandle);
                    }
                    authSession.isActive = false;
                    return _callIgnored(deleteAccessToken);
                  })));
                })));
              });
              var uploadFile = Upload_async(function(file) {
                var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var cancellationHandlers = [];
                var addCancellationHandler = function addCancellationHandler2(ca) {
                  cancellationHandlers.push(ca);
                };
                var cancel = function cancel2() {
                  return cancellationHandlers.forEach(function(x) {
                    return x();
                  });
                };
                if (params.onBegin !== void 0) {
                  params.onBegin({
                    cancel
                  });
                }
                return _catch(function() {
                  return _await(beginFileUpload(file, params, addCancellationHandler));
                }, function(e) {
                  cancel();
                  throw e;
                });
              });
              var url = function url2(filePath, slugOrParams) {
                var _a2;
                var defaultSlug = "raw";
                var params = typeof slugOrParams === "string" ? {
                  transformation: slugOrParams
                } : slugOrParams;
                return "".concat(cdnUrl, "/").concat(accountId, "/").concat((_a2 = params === null || params === void 0 ? void 0 : params.transformation) !== null && _a2 !== void 0 ? _a2 : defaultSlug).concat(filePath).concat((params === null || params === void 0 ? void 0 : params.auth) === true ? "?_auth=true" : "");
              };
              var self = {
                beginAuthSession,
                endAuthSession,
                uploadFile,
                url
              };
              var beginFileUpload = Upload_async(function(file, params, addCancellationHandler) {
                var progressSmoother = (0, external_progress_smoother_namespaceObject.ProgressSmoother)({
                  maxValue: file.size,
                  teardownTime: 1e3,
                  minDelayUntilFirstValue: 2e3,
                  valueIncreaseDelta: 200 * 1024,
                  valueIncreaseRatePerSecond: 50 * 1024,
                  averageTimeBetweenValues: 1e3
                  // When running, XHR should (hopefully) report at least every second, regardless of connection speed.
                });
                var reportProgress = function reportProgress2(stopReportingProgress) {
                  if (params.onProgress === void 0) {
                    stopReportingProgress();
                  } else {
                    var bytesSent = progressSmoother.smoothedValue();
                    var bytesTotal = file.size;
                    if (bytesSent === bytesTotal) {
                      stopReportingProgress();
                    }
                    params.onProgress({
                      bytesSent,
                      bytesTotal,
                      progress: Math.round(bytesSent / bytesTotal * 100)
                    });
                  }
                };
                return withProgressReporting(onProgressInterval, reportProgress, Upload_async(function() {
                  var uploadRequest = {
                    path: params.path,
                    metadata: params.metadata,
                    mime: normalizeMimeType(file.type),
                    originalFileName: file.name,
                    protocol: "1.1",
                    size: file.size,
                    tags: params.tags
                  };
                  debug("Initiating file upload. Params = ".concat(JSON.stringify(uploadRequest)));
                  return _await((0, upload_api_client_upload_js_namespaceObject.beginMultipartUpload)(getConfig(), accountId, uploadRequest), function(_beginMultipartUpload) {
                    var uploadMetadata = handleApiResult(_beginMultipartUpload);
                    debug("Initiated file upload. Metadata = ".concat(JSON.stringify(uploadMetadata)));
                    var incUploadIndex = function() {
                      var lastUploadIndex = 0;
                      return function() {
                        if (lastUploadIndex === uploadMetadata.uploadParts.count - 1) {
                          return void 0;
                        }
                        return ++lastUploadIndex;
                      };
                    }();
                    var nextPartQueue = [uploadMetadata.uploadParts.first];
                    var getNextPart = Upload_async(function(workerIndex) {
                      var nextPart = nextPartQueue.pop();
                      if (nextPart !== void 0) {
                        debug("Dequeued part ".concat(nextPart.uploadPartIndex, "."), workerIndex);
                        return nextPart;
                      }
                      var uploadPartIndex = incUploadIndex();
                      if (uploadPartIndex === void 0) {
                        debug("No parts remaining.", workerIndex);
                        return void 0;
                      }
                      debug("Fetching metadata for part ".concat(uploadPartIndex, "."), workerIndex);
                      return _await((0, upload_api_client_upload_js_namespaceObject.getUploadPart)(getConfig(), accountId, uploadMetadata.uploadId, uploadPartIndex), handleApiResult);
                    });
                    var bytesSentByEachWorker = [];
                    var uploadNextPart = function uploadNextPart2(workerIndex) {
                      return _await(getNextPart(workerIndex), function(nextPart) {
                        return _invokeIgnored(function() {
                          if (nextPart !== void 0) {
                            var lastBytesSent = 0;
                            var progress = function progress2(_ref) {
                              var bytesSent = _ref.bytesSent;
                              if (bytesSentByEachWorker[workerIndex] === void 0) {
                                bytesSentByEachWorker[workerIndex] = bytesSent;
                              } else {
                                bytesSentByEachWorker[workerIndex] -= lastBytesSent;
                                bytesSentByEachWorker[workerIndex] += bytesSent;
                              }
                              lastBytesSent = bytesSent;
                              var totalBytesSent = bytesSentByEachWorker.reduce(function(a, b) {
                                return a + b;
                              });
                              progressSmoother.setValue(totalBytesSent);
                            };
                            return _await(uploadPart(file, nextPart, progress, addCancellationHandler, workerIndex), function() {
                              return Upload_awaitIgnored(uploadNextPart2(workerIndex));
                            });
                          }
                        });
                      });
                    };
                    return _await(Promise.all(_toConsumableArray(Array(maxUploadConcurrency).keys()).map(function(workerIndex) {
                      return _await(uploadNextPart(workerIndex));
                    })), function() {
                      var uploadedFile = Object.assign({
                        accountId,
                        file
                      }, uploadMetadata.file);
                      debug("File upload completed.");
                      return uploadedFile;
                    });
                  });
                }));
              });
              var putUploadPart = Upload_async(function(url2, content, progress, addCancellationHandler) {
                var xhr = new XMLHttpRequest();
                var pending = true;
                addCancellationHandler(function() {
                  if (pending) {
                    xhr.abort();
                  }
                });
                return Upload_finallyRethrows(function() {
                  return _await(new Promise(function(resolve, reject) {
                    xhr.upload.addEventListener("progress", function(evt) {
                      if (evt.lengthComputable) {
                        progress({
                          bytesSent: evt.loaded,
                          bytesTotal: evt.total
                        });
                      }
                    }, false);
                    xhr.addEventListener("load", function() {
                      progress({
                        bytesSent: content.size,
                        bytesTotal: content.size
                      });
                      if (Math.floor(xhr.status / 100) === 2) {
                        var etag = xhr.getResponseHeader("etag");
                        if (etag === null || etag === void 0) {
                          reject(new Error("File upload error: no etag header in upload response."));
                        } else {
                          resolve({
                            etag
                          });
                        }
                      } else {
                        reject(new Error("File upload error: status code ".concat(xhr.status)));
                      }
                    });
                    xhr.onabort = function() {
                      return reject(new Error("File upload cancelled."));
                    };
                    xhr.onerror = function() {
                      return reject(new Error("File upload error."));
                    };
                    xhr.ontimeout = function() {
                      return reject(new Error("File upload timeout."));
                    };
                    xhr.open("PUT", url2);
                    xhr.send(content);
                  }));
                }, function(_wasThrown, _result) {
                  pending = false;
                  return Upload_rethrow(_wasThrown, _result);
                });
              });
              var uploadPart = Upload_async(function(file, part, progress, addCancellationHandler, workerIndex) {
                var content = part.range.inclusiveEnd === -1 ? new Blob() : file.slice(part.range.inclusiveStart, part.range.inclusiveEnd + 1);
                debug("Uploading part ".concat(part.uploadPartIndex, "."), workerIndex);
                return _await(putUploadPart(part.uploadUrl, content, progress, addCancellationHandler), function(_ref2) {
                  var etag = _ref2.etag;
                  return _await((0, upload_api_client_upload_js_namespaceObject.completeUploadPart)(getConfig(), accountId, part.uploadId, part.uploadPartIndex, {
                    etag
                  }), function(_completeUploadPart) {
                    handleApiResult(_completeUploadPart);
                    debug("Uploaded part ".concat(part.uploadPartIndex, "."), workerIndex);
                  });
                });
              });
              var withProgressReporting = Upload_async(function(tickInterval, tick, scope) {
                var whileReportingResolved;
                var whileReporting = new Promise(function(resolve) {
                  whileReportingResolved = resolve;
                });
                var isReporting = true;
                var stopReporting = function stopReporting2() {
                  if (isReporting) {
                    whileReportingResolved();
                    clearInterval(intervalHandle);
                    isReporting = false;
                  }
                };
                var intervalHandle = setInterval(function() {
                  return tick(stopReporting);
                }, tickInterval);
                return Upload_finallyRethrows(function() {
                  return Upload_call(scope, function(result) {
                    return _await(whileReporting, function() {
                      return result;
                    });
                  });
                }, function(_wasThrown2, _result2) {
                  stopReporting();
                  return Upload_rethrow(_wasThrown2, _result2);
                });
              });
              var deleteAccessToken = Upload_async(function() {
                return Upload_awaitIgnored(deleteNoResponse(
                  accessTokenUrl,
                  {},
                  true
                  // Required, else CDN response's `Set-Cookie` header will be silently ignored.
                ));
              });
              var callAuthMethod = Upload_async(function(other, me) {
                var authInstance = getAuthInstance();
                return _invokeIgnored(function() {
                  if (authInstance !== self) {
                    return Upload_awaitIgnored(other(authInstance));
                  } else {
                    return _callIgnored(me);
                  }
                });
              });
              var getAuthInstance = function getAuthInstance2() {
                var globalKey = "uploadJsAuthInstance";
                var globalAuthInstance = window[globalKey];
                if (globalAuthInstance === void 0) {
                  globalAuthInstance = self;
                  window[globalKey] = self;
                }
                return globalAuthInstance;
              };
              var refreshAccessToken = Upload_async(function(authUrl, authHeaders, authSession) {
                return _continueIgnored(_catch(function() {
                  return Upload_awaitIgnored(authMutex.safe(Upload_async(function() {
                    if (!authSession.isActive) {
                      return;
                    }
                    return Upload_call(authHeaders, function(_authHeaders) {
                      return _await(getAccessToken(authUrl, _authHeaders), function(token) {
                        return _await(putJsonGetJson(
                          accessTokenUrl,
                          {},
                          {
                            accessToken: token
                          },
                          true
                          // Required, else CDN response's `Set-Cookie` header will be silently ignored.
                        ), function(setTokenResult) {
                          var desiredTtlSeconds = setTokenResult.ttlSeconds - refreshBeforeExpirySeconds;
                          if (desiredTtlSeconds < minJwtTtlSeconds) {
                            warn("JWT expiration is too short: waiting for ".concat(minJwtTtlSeconds, " seconds before refreshing."));
                          }
                          authSession.accessToken = setTokenResult.accessToken;
                          authSession.accessTokenRefreshHandle = window.setTimeout(function() {
                            refreshAccessToken(authUrl, authHeaders, authSession).then(function() {
                            }, function(e) {
                              return error("Permanent error when refreshing access token: ".concat(e));
                            });
                          }, Math.max(minJwtTtlSeconds, desiredTtlSeconds) * 1e3);
                        });
                      });
                    });
                  })));
                }, function(e) {
                  error("Error when refreshing access token: ".concat(e));
                  return _await(new Promise(function(resolve) {
                    return setTimeout(resolve, retryAuthAfterErrorSeconds * 1e3);
                  }), function() {
                    return Upload_awaitIgnored(refreshAccessToken(authUrl, authHeaders, authSession));
                  });
                }));
              });
              var putJsonGetJson = Upload_async(function(url2, headers2, requestBody, withCredentials) {
                return _await(nonUploadApiRequest({
                  method: "PUT",
                  path: url2,
                  headers: headers2,
                  body: requestBody
                }, withCredentials), function(_nonUploadApiRequest) {
                  return _await(handleApiResult(_nonUploadApiRequest));
                });
              });
              var getAccessToken = Upload_async(function(authUrl, headers2) {
                var endpointName = "Your auth API endpoint";
                return _await(nonUploadApiRequest({
                  method: "GET",
                  path: authUrl,
                  headers: headers2
                }, false), function(result) {
                  if (!result.ok) {
                    throw new Error("".concat(logPrefix).concat(endpointName, " returned a failed response. Please ensure the endpoint's status code is 200."));
                  }
                  var jwt = result.body;
                  if (typeof jwt !== "string") {
                    throw new Error("".concat(logPrefix).concat(endpointName, " returned an unsupported response. Please ensure: 1) 'Content-Type: text/plain' is in the HTTP response headers 2) the status code is 200."));
                  }
                  if (jwt.length === 0) {
                    throw new Error("".concat(logPrefix).concat(endpointName, " returned an empty string. Please return a valid JWT instead."));
                  }
                  if (jwt.trim().length !== jwt.length) {
                    throw new Error("".concat(logPrefix).concat(endpointName, " returned whitespace around the JWT, please remove it."));
                  }
                  return jwt;
                });
              });
              var deleteNoResponse = Upload_async(function(url2, headers2, withCredentials) {
                return _await(nonUploadApiRequest({
                  method: "DELETE",
                  path: url2,
                  headers: headers2
                }, withCredentials), function(_nonUploadApiRequest2) {
                  handleApiResult(_nonUploadApiRequest2);
                });
              });
              var handleApiResult = function handleApiResult2(result) {
                var _a2;
                if (result.ok) {
                  return result.body;
                }
                var errorResponseMaybe = result.body;
                if (typeof ((_a2 = errorResponseMaybe === null || errorResponseMaybe === void 0 ? void 0 : errorResponseMaybe.error) === null || _a2 === void 0 ? void 0 : _a2.code) === "string") {
                  throw new UploadApiError(errorResponseMaybe);
                }
                throw new Error("".concat(logPrefix, "Unexpected API error."));
              };
              var nonUploadApiRequest = Upload_async(function(options, withCredentials) {
                return (0, upload_api_client_upload_js_namespaceObject.request)({
                  BASE: options.path,
                  WITH_CREDENTIALS: withCredentials
                }, Object.assign(Object.assign({}, options), {
                  path: ""
                  // We set to "" because we're using "BASE" above instead.
                }));
              });
              var getConfig = function getConfig2() {
                var apiConfig = {
                  BASE: apiUrl,
                  WITH_CREDENTIALS: true
                };
                if (authenticateWithApiKey) {
                  apiConfig.USERNAME = "apikey";
                  apiConfig.PASSWORD = config.apiKey;
                }
                var accessToken = lastAuthSession === null || lastAuthSession === void 0 ? void 0 : lastAuthSession.accessToken;
                if (headers !== void 0 || accessToken !== void 0) {
                  apiConfig.HEADERS = Upload_async(function() {
                    return _await(headers === void 0 ? {} : headers(), function(headersFromConfig) {
                      var accessToken2 = lastAuthSession === null || lastAuthSession === void 0 ? void 0 : lastAuthSession.accessToken;
                      return Object.assign(Object.assign({}, headersFromConfig), accessToken2 === void 0 ? {} : {
                        "authorization-token": accessToken2
                      });
                    }, headers === void 0);
                  });
                }
                return apiConfig;
              };
              var normalizeMimeType = function normalizeMimeType2(mime) {
                var normal = mime.toLowerCase();
                var regex = /^[a-z0-9]+\/[a-z0-9+\-._]+(?:;[^=]+=[^;]+)*$/;
                return regex.test(normal) ? normal : void 0;
              };
              var debug = function debug2(message, workerIndex) {
                if (debugMode) {
                  console.log("".concat(logPrefix).concat(message).concat(workerIndex !== void 0 ? " (Worker ".concat(workerIndex, ")") : ""));
                }
              };
              var error = function error2(message) {
                console.error("".concat(logPrefix).concat(message));
              };
              var warn = function warn2(message) {
                console.warn("".concat(logPrefix).concat(message));
              };
              return self;
            }
            ;
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        if (__webpack_module_cache__[moduleId]) {
          return __webpack_module_cache__[moduleId].exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      !function() {
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      }();
      return __webpack_require__("./src/index.ts");
    }();
  }
});
export default require_main3();
//# sourceMappingURL=upload-js.js.map
